#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdint.h>

const off_t PL310_BASE = 0x00A02000;
const size_t PAGE_SIZE = 4096;

const off_t COUNTER0 = 0x210;
const off_t COUNTER1 = 0x20C;

/*
 *  mmap helper functions  
 */
void* map_base(off_t base_address) {
    int fd = open("/dev/mem", O_RDWR);
    if (fd < 0)
        return MAP_FAILED;

    void *ptr = mmap(NULL, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, base_address);
    close(fd);
    
    return ptr;
}

void umap_base(void* base_ptr) {
    munmap(base_ptr, PAGE_SIZE);
}

/*
 * Register access helper functions
 */
uint32_t read_mem_register(void* base_ptr, off_t offset) {
    uint32_t* ptr = base_ptr + offset;
    return *ptr; 
}

void write_mem_register(void* base_ptr, off_t offset, uint32_t value) {
    uint32_t* ptr = base_ptr + offset;
    *ptr = value;
}

/*
 * Program to track PL310 events while doing PLD requests
 */
int main(int argc, char const *argv[])
{
    uint32_t val;
    uint32_t epfalloc, dwreq;
    int data[10000];
    int iterations;

    /* Read iterations from console */
    if (argc == 1) {
        iterations = 100;
    } else {
        iterations = atoi(argv[1]);
    }
    printf("Doing %d iterations\n", iterations);

    /* Init mapping to PL310 registers */
    void* pl310_ptr = map_base(PL310_BASE);
    if (pl310_ptr == MAP_FAILED) {
        printf("mmap failed");
        return -1;
    }

    /* Enable and reset PL310 counters */
    val = 0b111;
    write_mem_register(pl310_ptr, 0x200, val);  // reg2_ev_counter_ctrl
    
    val = read_mem_register(pl310_ptr, 0x200);
    printf("reg2_ev_counter_ctrl = 0x%x\n", val);

    /* Configure counter0 (cfg in 0x208) to track prefetch hint allocated into L2 (EPFALLOC 0b1100) */
    val = 0b110000;  // EPFALLOC + no interruptions
    write_mem_register(pl310_ptr, 0x208, val);  // reg2_ev_counter0_cfg
    
    val = read_mem_register(pl310_ptr, 0x208);
    printf("reg2_ev_counter0_cfg = 0x%x\n", val);

    /* Configure counter1 (cfg in 0x204) to track L2 write lookup (request) (DWREQ b0101) */
    // b101000 for IPFALLOC (hints generated by PL310)
    val = 0b010100;  // DWREQ + no interruptions
    write_mem_register(pl310_ptr, 0x204, val);  // reg2_ev_counter1_cfg

    val = read_mem_register(pl310_ptr, 0x204);
    printf("reg2_ev_counter1_cfg = 0x%x\n", val);

    /* Iterate prefetches */
    for (int i=0; i<iterations; i++) {
        epfalloc = read_mem_register(pl310_ptr, COUNTER0);
        dwreq = read_mem_register(pl310_ptr, COUNTER1);
        printf("(%d) EPFALLOC=%d, DWREQ=%d\n", i, epfalloc, dwreq);

        //asm volatile("pld\t[%0]" :: "r" (data+i));
         __builtin_prefetch (data+i, 0, 3);
    }
    
    /* Disable counters */
    val = 0b110;
    write_mem_register(pl310_ptr, 0x200, val);  // reg2_ev_counter_ctrl

    /* Unmap PL310  */
    umap_base(pl310_ptr);

    return 0;
}
